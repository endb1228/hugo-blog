+++
title = '[Spring] 퍼사드 패턴'
date = 2024-09-05T16:01:23+09:00
draft = false
+++

커맨드 패턴에 대해서 이런 저런 고민을 하면서 정리하기 위해 지난 포스팅을 작성했다. 
그러면서 퍼사드 패턴의 필요성에 대해 한 번 더 느끼게 되면서 어떤 패턴인지 간단하게 정리한다.

## 커맨드 패턴의 사용
지난 포스팅에서 커맨드 패턴에 대해 고찰하면서, 커맨드 패턴을 사용할 때
컨트롤러에서 여러 개의 서비스를 의존하거나 서비스에서 여러 개의 리포지토리를 의존할 때 발생할 수 있는 문제점에 대해서 생각하게 됐다.   

먼저 컨트롤러에서 1개의 서비스를 의존할 때를 생각해보자.
커맨드 패턴을 사용하기 위해서는 리퀘스트에서 먼저 `toCommand`함수로 커맨드 객체를 생성하고, 해당 객체를 서비스의 원하는 함수에 사용한다.

그런데 만약 컨트롤러에서 2개의 서비스를 의존하고, 하나의 api 안에서 각각의 서비스의 함수를 호출한다면?
커맨드 객체를 만들어서 서비스1에서 사용하더라도, 서비스2의 함수를 호출할 때 문제가 된다.

`UserService.getUser`에서 유저 정보를 가져오고, `ProductService.getProduct`를 호출하는 시나리오를 예로 들어보자.  
먼저 리퀘스트에서 `toCommand` 함수로 커맨드 객체를 생성하고, `getUser`에 파라미터로 사용한다.  
여기서 `getProduct`함수는 유저 정보만을 사용할 수도, 커맨드 객체도 함께 사용할 수도 있다.
그리고 해당 api 뿐만 아니라 다른 api에서도 사용하는 함수일 수도 있다.
물론 각각의 api에서 개별 함수로 만들어도 되지만, 유사한 동작을 하는 함수를 여러 개 만들면서 협업 시에 혼란을 야기할 수도 있다.

그리고 가장 치명적인 건 컨트롤러에서 흐름이 제어되기 떄문에 **트랜잭션 처리가 어렵다**는 것이다.

## 퍼사드 패턴
위의 시나리오에서 문제가 발생한 이유는 뭘까?
각각의 함수가 필요로 하는 정보가 다르기 떄문에,
정보 은닉을 위해 리퀘스트를 직접 받거나 엔티티를 사용하는 대신
커맨드 패턴을 활용해 커맨드 객체를 만들어서 사용했다.
하지만 그게 함수의 재사용성을 떨어뜨리고, 코드를 수정하기 힘들게 만든다.

이러한 문제를 해결하기 위해 컨트롤러 레이어와 서비스 레이어 사이에 퍼사드 레이어를 하나 만들어서
컨트롤러가 비즈니스 로직에 대해 알지 못 하게 하고
서비스 레이어에서는 더 유연하게 대처할 수 있도록 한다.

컨트롤러는 필요한 서비스를 모두 주입받는 대신, 퍼사드 서비스 1개만 주입받는다.
그리고 퍼사드 서비스에서는 필요한 서비스를 모두 주입받는다.
컨트롤러에서 퍼사드 서비스의 함수를 호출할 때에는 커맨드 객체만 사용하면 되며,
퍼사드 서비스는 커맨드 객체를 이용하여 각각에 서비스에 필요로 하는 파라미터를 제공한다.
이 과정에서는 정보 은닉에 대한 부담이 적으며, 트랜잭션도 관리할 수 있다.

단점은 레이어를 하나 더 만들기 때문에 구조가 더 복잡해진다는 것이다.
관리해야 할 도메인이 많아지면 그만큼 서비스와 컨트롤러도 많아질 것이고,
퍼사드 서비스도 여러 개로 분리하겠지만 그럼에도 구조가 복잡해지는 것은 불가피해진다.
